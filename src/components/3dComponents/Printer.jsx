// /*
// Auto-generated by: https://github.com/pmndrs/gltfjsx
// */

// import React, { useRef } from 'react'
// import { useGLTF } from '@react-three/drei'

// export default function Model(props) {
//   const { nodes, materials } = useGLTF('./models/Printer.glb')
//   return (
//     <group {...props} dispose={null}>
//     <group  scale={0.4}>
//       <mesh
//         castShadow
//         receiveShadow
//         geometry={nodes.Plane003.geometry}
//         material={materials['CreamGloss.002']}
//       />
//       <mesh
//         castShadow
//         receiveShadow
//         geometry={nodes.Plane003_1.geometry}
//         material={materials.Blue}
//       />
//       <mesh
//         castShadow
//         receiveShadow
//         geometry={nodes.Plane003_2.geometry}
//         material={materials.Grey}
//       />
//     </group>
//   </group>
//   )
// }

// useGLTF.preload('./models/Printer.glb')


/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef, useState } from 'react'
import { useGLTF } from '@react-three/drei'
import * as THREE from 'three'
// import { useModelContext } from '../../context/ModelContext';
import { useAppSelector } from '../../redux/hooks';
import { setCurrentInstrumentSelected, setInstrumentArray } from '../../redux/slices/instrument';
import { useDispatch } from 'react-redux';

export default function Model(props) {

  const meshRef = useRef()
  const { nodes:tableNode } = useGLTF("./models/Table.glb");
  const tableBoundingBox = new THREE.Box3().setFromObject(tableNode.Plane002_3);
  const tableHeight = tableBoundingBox.max.y;
  const tableWidth = tableBoundingBox.max.x;
  const tableStartIndex = tableBoundingBox.min.x;

  // const {currentInstrument, setCurrentInstrument, hotelSelected, setHotelSelected} = useModelContext()
  // const currentInstrument = useAppSelector(state => state.instrument);
  const currentInstrumentSelected = useAppSelector(state => state.instrument.instrumentSelected);
  const currentInstrument = useAppSelector(state => state.instrument.instrument);

  const instrumentsList = useAppSelector(state => state.instrument.instrumentsList);
  
  // useEffect(() => {
  //   console.log(instrumentsList)
  // },[instrumentsList])

  const dispatch = useDispatch();


  const [positionArr, setPositionArr] = useState([0.25]);
  const [zArr, setZArr] = useState([-0.4, 0.45]);
  const [xArr, setXArr] = useState([tableStartIndex + 2.2, tableStartIndex + 2.2,]);

  const setPositions = () => {
  let totalItemsOnTop = 2;
    let arr = [];
    arr.push(tableStartIndex + 1.59);
    for (let i = 0; i < totalItemsOnTop; i++) {
      arr.push(arr[i - 1] + 0.6);
    }
    setPositionArr(arr);
  };

  useEffect(() => {
    setPositions();
  }, []);

 const placeHotel = (e, index) => {
    console.log("Placing")
    const newMesh = {
      rotation: [],
      position: [xArr[index], 0, zArr[index]],
      shape: 'printer'
    }
    dispatch(setInstrumentArray(newMesh))
    dispatch(setCurrentInstrumentSelected(false));
    e.stopPropagation();
  }

 const PrinterModel = ({positions}) => {
  const { nodes, materials } = useGLTF('./models/Printer.glb')
  return(
       <group {...props} dispose={null} >
    <group  scale={0.22} position={[positions[0], tableHeight/5.5, positions[2]]}>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Plane003.geometry}
        material={materials['CreamGloss.002']}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Plane003_1.geometry}
        material={materials.Blue}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Plane003_2.geometry}
        material={materials.Grey}
      />
    </group>
  </group>
  )
 }


  return (
    <>
        {currentInstrument=='printer' && currentInstrumentSelected && positionArr.map((val, index) => {
            return (
              <mesh
                key={index}
                ref={meshRef}
                onClick={(e) => {placeHotel(e, index)}}
                position={[xArr[index], tableHeight/2.5, zArr[index]]}
              >
                <boxGeometry args={[1.4, 0.001, 0.7]} />
                <meshStandardMaterial color={0x2c9e93} transparent={true} opacity={0.4}/>
              </mesh>
            );
          })}
          {instrumentsList.filter(mesh => mesh.shape === 'printer').map((mesh, index) =>{ return (
            <mesh key={index} >
              <PrinterModel positions={mesh.position}/>
            </mesh>
          )})}
    </>
  )
}

useGLTF.preload('./models/Printer.glb')