// useGLTF.preload('./models/PC.glb')

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef, useState } from 'react'
import { useGLTF } from '@react-three/drei'
import { Box3 } from 'three';
import { useAppSelector } from '../../redux/hooks';
import { useDispatch } from 'react-redux';
import { setCurrentInstrumentSelected, setInstrumentArray } from '../../redux/slices/instrument';

export default function Model(props) {

  const dispatch = useDispatch()

  const meshRef = useRef()
  const [positionArr, setPositionArr] = useState([0.25]);
  const setPositions = () => {
    let totalItemsOnTop = 8;
      let arr = [];
      for (let i = 0; i < totalItemsOnTop; i++) {
        arr.push(arr[i - 1] + 0.6);
      }
      setPositionArr(arr);
    };
  
    useEffect(() => {
      setPositions();
    }, []);
  const currentInstrumentSelected = useAppSelector(state => state.instrument.instrumentSelected);
  const currentInstrument = useAppSelector(state => state.instrument.instrument);

  const instrumentsList = useAppSelector(state => state.instrument.instrumentsList);
  

  const { nodes:tableNode } = useGLTF("./models/Table.glb");
  const tableBoundingBox = new Box3().setFromObject(tableNode.Plane002_3);
  const tableHeight = tableBoundingBox.max.y;
  const tableWidth = tableBoundingBox.max.x;
  const tableStartIndex = tableBoundingBox.min.x;
  console.log(tableHeight, tableWidth, tableStartIndex);

  const [zArr, setZArr] = useState([
    tableStartIndex/2, tableStartIndex/2, 
    -tableStartIndex/2, -tableStartIndex/2
  ]);
  const [xArr, setXArr] = useState([
    0.85 ,-0.85,
    0.85,-0.85]);

const PCModel = ({positions, rotation}) => {
  const { nodes, materials } = useGLTF('./models/PC.glb')
  return (
    <group {...props} dispose={null} scale={1} position={[positions[0],positions[1],positions[2]]}>
      <group rotation={[rotation[0], rotation[1], rotation[2]]}>
        <mesh
          geometry={nodes.Shape_IndexedFaceSet033.geometry}
          material={materials['metalic plate']}
        />
        <mesh geometry={nodes.Shape_IndexedFaceSet033_1.geometry} material={materials.WhiteGloss} />
        <mesh
          geometry={nodes.Shape_IndexedFaceSet033_2.geometry}
          material={materials['plastic black']}
        />
        <mesh geometry={nodes.Shape_IndexedFaceSet033_3.geometry} material={materials.Keyboard} />
        <mesh
          geometry={nodes.Shape_IndexedFaceSet033_4.geometry}
          material={materials['Black Plastic']}
        />
        <mesh geometry={nodes.Shape_IndexedFaceSet033_5.geometry} material={materials.BlueMetal} />
      </group>
    </group>
  )
}
  const placePC = (e, index) => {
      console.log("Placing")
      let rotation;
      if(index === 0){
        rotation = [Math.PI / 2, 0, Math.PI]          
      }
      else if(index === 1){
        rotation= [Math.PI / 2, 0, Math.PI]          
      }
      else if(index === 2){
        rotation= [Math.PI / 2, 0, 0]          
      }
      else if(index === 3){
        rotation= [Math.PI / 2, 0, 0]          
      }
      const newMesh = {
        rotation: rotation,
        position: [xArr[index], tableWidth/2, zArr[index]],
        shape: 'pc'
      }
      dispatch(setInstrumentArray(newMesh))
      dispatch(setCurrentInstrumentSelected(false));
      e.stopPropagation();
    }
return (
  <>
        {currentInstrument=='pc' && currentInstrumentSelected && positionArr.map((val, index) => {
            return (
              <mesh
                // visible={()=>checkIfModelPresent()}
                key={index}
                ref={meshRef}
                onClick={(e) => {placePC(e, index)}}
                position={[xArr[index], tableHeight/2.5, zArr[index]]}
              >
                <boxGeometry args={[0.1, 0.001, 0.1]} />
                <meshStandardMaterial color={0x2c9e93} transparent={true} opacity={0.4}/>
              </mesh>
            );
          })}
          {instrumentsList.filter(mesh => mesh.shape === 'pc').map((mesh, index) =>{ return (
            <mesh key={index} >
              <PCModel positions={mesh.position} rotation={mesh.rotation}/>
            </mesh>
          )})}
    </>
)
}

useGLTF.preload('./models/PC.glb')